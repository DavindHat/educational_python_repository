# Что фундаментальное необходимо знать и понимать для понимания архитектуры языков в тч python

Память - stack, heap, аллокации, поинтеры, размеры объектов и почему их надо знать
на этапе компиляции.
Как на основе страктов с привязанными методами получаются зачатки ООП.
Как работают функции - стак фреймы, функции как объекты в памяти.
Из чего состоит бинарник, что такое дата сегмент, принципиальные отличия от io данных.
Программный интерфейс процессора (asm)(принципы).
Интерфейсы и хедеры.
IO, взаимодействие с ОС, основы ОС - файлы, сокеты, переменные окружения, процессы.
Линкование.

"Воркфлоу" пайтона - компиляция, байткод, интерпретация.
Классы как объекты в пайтоне.
Дандер методы - коллекции, итераторы и прочие базовые протоколы.
Когда ты исполняешь пайтон программу, какие "куски" являются С кодом, а какие - пайтон.

Если хочешь разобраться с архитектурой ЯП, лучше всего потратить время на С.

# Структуры sql баз данных инструменты и методы

Разные БД **очень** сильно отличаются по своей структуре. У реляционных БД есть только
одно обязательное общее условие - они все имплементируют интерфейс sql. Т.е. все умеют
работать с sql запросами. Как именно они хранят данные и обрабатывают запросы - везде
по-разному.

Например sqlite умеет "хранить" все свои данные в памяти, после завершения процесса
все данные удаляются. Еще умеет хранить данные в одном файле.

БД вроде postgres намного сложнее. Как именно хранятся файлы на диске обычно скрыто от
пользователей, это не имеет большого значения. На разных ОС система хранения может
отличаться. Сама бд запускает несколько типов процессов

1. Сервер. Принимает sql запросы, возможно проводит первичную валидацию, проверяет
права.
1. Воркер. Строит план исполнения sql запроса и исполняет его.
1. Мемори кеш. Чтобы не читать каждый раз с диска, воркеры могут читать
данные из кеша
1. Writers. Большая часть работы воркеров происходит в памяти. После завершения
транзакции все изменения необходимо записать на диск. Этим занимается отдельный процесс.
1. Checkpointer. Синхронизирует данные в памяти воркеров с диском, проверяет
консистентность данных. Если данные расходятся, writer не сможет записывать на диск.
1. Логгер
1. Автоакуум. Удаляет все лишние данные, создаваемые при локальном исполнении
транзакций. Что то вроде GC.
1. Профайлер. Следит за скоростью исполнения запросов, смотрит планы запросов, создает
отчеты.
1. Несколько других. Вся архитектура довольно сложная, это были основные процессы

Один из самых важных паттернов при работе с бд - транзакции. Это инструмент,
обеспечивающий атомарность группы операций. Для каждой транзакции создается своя CoW 
"ветка" базы данных, которая мерджится в основную бд при успешном завершении транзакции.

Если абстрагироваться от постгреса, почти все бд состоят из 2 компонентов - клиента
и сервера. Сервер - это то, что принимает sql запросы, обрабатывает их и возвращает
результат. Он также записывает данные на диск. Клиент - это то, что создает и отправляет 
запросы. Это может быть терминальная утилита (psql), гуи программа (dbeaver, pgAdmin),
или программа, которую ты напишешь, которая в процессе работы будет сама отправлять sql
запросы. Сервер не знает и не должен знать о том, какой тип клиента он обслуживает. Все,
что он должен уметь делать - работать по протоколу sql.

Сервер может быть запущен локально, или крутиться на хосте.

# Работа с удаленными серверами по различным протоколам

Советую почитать про osi и tcp/ip модели. Это +- одно и то же.

Описать протоколы - tcp, udp, http1.1, http2.0. http3.0, tls, ws, grpc, amqp
Описать ip интерфейсы ОС, роутинг.
Описать какую работу по обработке пакетов берет на себя ОС, а какую - клиент.
Описать как работа с серверами выглядит со стороны клиентского приложения.
Как запрос, который приходит на сокет, доходит до приложения.
Немного про асинхронность, iouring, трединг.

# Структура удаленных серверов, архитектура

Архитектура сервера зависит от того, чем этот сервер занимается, как он хостится, как
разворачивается, обновляется итд. Существуют простейшие сервера, которые принимают
query запрос (например GET /user {"name": "Fedor"} - тут, думаю, все понятно), находят
данные в ДБ, и возвращают результат. Есть более сложные сервера, которые в процессе
своей работы шлют запросы на другие сервера. Эти другие сервера могут являться частью
инфраструктуры, или быть внешними. Например, все приложения, которые используют chatGPT,
при каждом запросе пользователя шлют запросы к серверам chatGPT, получают и обрабатывают
ответ, и только после этого возвращают ответ пользователю.
Эта структура может быть сколь угодно сложной.

# Как происходят взаимодействия с удаленными серверами

Для взаимодействия с сервером пользователю нужна клиентская программа, которая умеет
отправлять запросы к нужному серверу, принимать и обрабатывать результаты. Чаще всего
эта программа - это фронтенд в браузере. Или десктопное или мобильное приложение.
Серверу чаще всего иррелевантно, какой клиент к нему обратится. У сервера есть
определенный протокол, по которому он работает.

Кроме уже готовых клиентских программ, пользователь может написать свою. Для этого
ему нужна документация по API сервера, а также язык программирования,
компилятор/рантайм, нужные http (или другие) библиотеки (даже если они самописные), и
ОС, через которую можно будет слать ip пакеты на нужный адрес.
-Найти и показать пример swagger документации

# Немного про докер

Image
Сontainer
Dockerfile
docker-compose
volumes
Как создается контейнер
IP интерфейсы, порты


